import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Political markets being monitored
  markets: defineTable({
    polymarketId: v.string(),
    slug: v.string(),
    question: v.string(),
    category: v.string(),
    endDate: v.optional(v.number()),
    isActive: v.boolean(),
    totalVolume: v.number(),
    outcomes: v.array(
      v.object({
        name: v.string(),
        tokenId: v.string(),
        price: v.number(),
      }),
    ),
    lastSyncedAt: v.number(),
    // Incremental analysis checkpoints
    lastAnalyzedAt: v.optional(v.number()),
    lastAnalyzedTradeTimestamp: v.optional(v.number()),
    // Cached market context (refreshed hourly)
    cachedContext: v.optional(
      v.object({
        avgTradeSize: v.number(),
        totalVolume: v.number(),
        totalHolders: v.number(),
        cachedAt: v.number(),
      }),
    ),
  })
    .index("by_polymarket_id", ["polymarketId"])
    .index("by_category", ["category"])
    .index("by_active", ["isActive"]),

  // Trader accounts observed
  accounts: defineTable({
    address: v.string(),
    displayName: v.optional(v.string()),
    previousNames: v.array(v.string()),
    firstSeenAt: v.number(),
    createdAt: v.optional(v.number()),
    accountAgeDays: v.optional(v.number()),
    totalTrades: v.number(),
    totalVolume: v.number(),
    winCount: v.number(),
    lossCount: v.number(),
    winRate: v.number(),
    riskScore: v.number(),
    flags: v.array(v.string()),
    lastActivityAt: v.number(),
    isFlagged: v.boolean(),
    // Cached profile for cost optimization (refreshed when new activity detected)
    lastAnalyzedAt: v.optional(v.number()),
    cachedProfile: v.optional(
      v.object({
        profitLossUsd: v.number(),
        avgTradeSize: v.number(),
        uniqueMarkets: v.number(),
        cachedAt: v.number(),
      }),
    ),
    // Skip re-analysis flag (already cleared or confirmed)
    analysisStatus: v.optional(
      v.union(
        v.literal("pending"),
        v.literal("cleared"),
        v.literal("confirmed"),
      ),
    ),
  })
    .index("by_address", ["address"])
    .index("by_risk_score", ["riskScore"])
    .index("by_flagged", ["isFlagged"]),

  // Detection alerts generated by agent
  alerts: defineTable({
    accountId: v.id("accounts"),
    accountAddress: v.string(), // Denormalized for display
    marketId: v.optional(v.id("markets")),
    severity: v.union(
      v.literal("low"),
      v.literal("medium"),
      v.literal("high"),
      v.literal("critical"),
    ),
    signalType: v.union(
      v.literal("new_account_large_bet"),
      v.literal("timing_correlation"),
      v.literal("statistical_improbability"),
      v.literal("account_obfuscation"),
      v.literal("disproportionate_bet"),
      v.literal("pattern_match"),
    ),
    title: v.string(),
    description: v.string(),
    evidence: v.object({
      metrics: v.object({
        riskScore: v.optional(v.number()),
        originalRiskScore: v.optional(v.number()),
        tradeCountPenalty: v.optional(v.number()),
        probability: v.optional(v.number()),
        totalProfit: v.optional(v.number()),
        totalVolume: v.optional(v.number()),
        winRate: v.optional(v.number()),
        accountAgeDays: v.optional(v.number()),
        totalTrades: v.optional(v.number()),
        uniqueMarketsTraded: v.optional(v.number()),
      }),
      reasoning: v.string(),
    }),
    status: v.union(
      v.literal("new"),
      v.literal("investigating"),
      v.literal("confirmed"),
      v.literal("dismissed"),
    ),
    createdAt: v.number(),
    updatedAt: v.number(),
    agentRunId: v.optional(v.id("agentRuns")),
  })
    .index("by_account", ["accountId"])
    .index("by_severity", ["severity"])
    .index("by_status", ["status"])
    .index("by_created", ["createdAt"]),

  // Agent execution logs
  agentRuns: defineTable({
    startedAt: v.number(),
    completedAt: v.optional(v.number()),
    status: v.union(
      v.literal("running"),
      v.literal("completed"),
      v.literal("failed"),
    ),
    triggerType: v.union(
      v.literal("scheduled"),
      v.literal("manual"),
      v.literal("realtime_trigger"),
    ),
    marketIds: v.array(v.id("markets")),
    accountsAnalyzed: v.number(),
    alertsGenerated: v.number(),
    toolCalls: v.array(
      v.object({
        tool: v.string(),
        input: v.object({
          marketId: v.optional(v.string()),
          address: v.optional(v.string()),
          severity: v.optional(v.string()),
        }),
        output: v.object({
          trades: v.optional(v.number()),
          suspicious: v.optional(v.number()),
          age: v.optional(v.number()),
          winRate: v.optional(v.number()),
          success: v.optional(v.boolean()),
        }),
        timestamp: v.number(),
      }),
    ),
    tokensUsed: v.object({
      input: v.number(),
      output: v.number(),
    }),
    error: v.optional(v.string()),
  })
    .index("by_started", ["startedAt"])
    .index("by_status", ["status"]),

  // Real-time activity feed for UI
  activityFeed: defineTable({
    type: v.union(
      v.literal("trade_detected"),
      v.literal("alert_created"),
      v.literal("agent_started"),
      v.literal("agent_completed"),
      v.literal("market_synced"),
      v.literal("detection_completed"),
    ),
    payload: v.object({
      // alert_created
      alertId: v.optional(v.id("alerts")),
      severity: v.optional(v.string()),
      title: v.optional(v.string()),
      accountAddress: v.optional(v.string()),
      // agent_started / agent_completed
      runId: v.optional(v.id("agentRuns")),
      triggerType: v.optional(v.string()),
      accountsAnalyzed: v.optional(v.number()),
      alertsGenerated: v.optional(v.number()),
      duration: v.optional(v.number()),
      // market_synced
      marketsUpdated: v.optional(v.number()),
      // detection_completed
      mode: v.optional(v.string()),
      suspectsFound: v.optional(v.number()),
    }),
    timestamp: v.number(),
  }).index("by_timestamp", ["timestamp"]),
});
