<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARGUS â€” The All-Seeing Eye</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #030303;
            --accent: #f59e0b;
            --accent-dim: rgba(245, 158, 11, 0.6);
            --text: #e8e8e8;
            --muted: #666;
            --font-mono: 'JetBrains Mono', monospace;
            --font-serif: 'Instrument Serif', serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--font-mono);
            font-weight: 300;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        /* Left Panel - Content */
        .content-panel {
            width: 40%;
            padding: 4rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            z-index: 10;
        }

        .wordmark {
            font-family: var(--font-serif);
            font-size: clamp(3rem, 6vw, 5rem);
            font-weight: 400;
            letter-spacing: 0.15em;
            color: var(--text);
            margin-bottom: 0.5rem;
            opacity: 0;
            animation: fadeSlideUp 0.8s ease-out 0.2s forwards;
        }

        .tagline {
            font-family: var(--font-serif);
            font-style: italic;
            font-size: clamp(1rem, 2vw, 1.4rem);
            color: var(--accent);
            margin-bottom: 2.5rem;
            opacity: 0;
            animation: fadeSlideUp 0.8s ease-out 0.4s forwards;
        }

        .description {
            font-size: 0.85rem;
            line-height: 1.8;
            color: var(--muted);
            max-width: 380px;
            margin-bottom: 3rem;
            opacity: 0;
            animation: fadeSlideUp 0.8s ease-out 0.6s forwards;
        }

        .stats {
            display: flex;
            gap: 3rem;
            opacity: 0;
            animation: fadeSlideUp 0.8s ease-out 0.8s forwards;
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 500;
            color: var(--text);
            letter-spacing: 0.05em;
        }

        .stat-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--muted);
        }

        .status {
            display: flex;
            align-items: center;
            gap: 0.6rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
            box-shadow: 0 0 12px var(--accent-dim);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.85); }
        }

        @keyframes fadeSlideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Right Panel - Visual Effect */
        .visual-panel {
            width: 60%;
            position: relative;
            overflow: hidden;
        }

        #pixelCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Grain overlay */
        .grain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* Vignette */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 30%, var(--bg) 100%);
        }

        /* Scanline effect */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.15) 2px,
                rgba(0, 0, 0, 0.15) 4px
            );
            opacity: 0.3;
        }

        /* Edge fade into content panel */
        .edge-fade {
            position: absolute;
            top: 0;
            left: 0;
            width: 120px;
            height: 100%;
            background: linear-gradient(90deg, var(--bg) 0%, transparent 100%);
            pointer-events: none;
            z-index: 5;
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
            }
            .content-panel {
                width: 100%;
                height: 50%;
                padding: 2rem;
            }
            .visual-panel {
                width: 100%;
                height: 50%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content-panel">
            <h1 class="wordmark">ARGUS</h1>
            <p class="tagline">The All-Seeing Eye</p>
            <p class="description">
                Autonomous detection of insider trading patterns across political prediction markets.
                Machine intelligence monitoring the watchers.
            </p>
            <div class="stats">
                <div class="stat">
                    <span class="stat-value">24</span>
                    <span class="stat-label">Markets Monitored</span>
                </div>
                <div class="stat">
                    <div class="status">
                        <span class="status-dot"></span>
                        <span class="stat-value">ACTIVE</span>
                    </div>
                    <span class="stat-label">System Status</span>
                </div>
            </div>
        </div>
        <div class="visual-panel">
            <canvas id="pixelCanvas"></canvas>
            <div class="edge-fade"></div>
            <div class="scanlines"></div>
            <div class="grain"></div>
            <div class="vignette"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const PIXEL_SIZE = 4;
        const GAP = 1;
        const CELL = PIXEL_SIZE + GAP;

        // Colors
        const ACCENT_R = 245, ACCENT_G = 158, ACCENT_B = 11;

        // State
        let width, height, cols, rows;
        let time = 0;
        let ripples = [];
        let mouseX = 0, mouseY = 0;
        let lastMouseX = 0, lastMouseY = 0;

        // Bayer 8x8 dithering matrix
        const BAYER_8x8 = [
            [ 0, 32,  8, 40,  2, 34, 10, 42],
            [48, 16, 56, 24, 50, 18, 58, 26],
            [12, 44,  4, 36, 14, 46,  6, 38],
            [60, 28, 52, 20, 62, 30, 54, 22],
            [ 3, 35, 11, 43,  1, 33,  9, 41],
            [51, 19, 59, 27, 49, 17, 57, 25],
            [15, 47,  7, 39, 13, 45,  5, 37],
            [63, 31, 55, 23, 61, 29, 53, 21]
        ].map(row => row.map(v => v / 64));

        // Noise functions
        function hash(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        function smoothNoise(x, y) {
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            const fx = x - ix;
            const fy = y - iy;

            const sx = fx * fx * (3 - 2 * fx);
            const sy = fy * fy * (3 - 2 * fy);

            const n00 = hash(ix, iy);
            const n10 = hash(ix + 1, iy);
            const n01 = hash(ix, iy + 1);
            const n11 = hash(ix + 1, iy + 1);

            const nx0 = n00 * (1 - sx) + n10 * sx;
            const nx1 = n01 * (1 - sx) + n11 * sx;

            return nx0 * (1 - sy) + nx1 * sy;
        }

        function fbm(x, y, octaves = 4) {
            let value = 0;
            let amplitude = 0.5;
            let frequency = 1;
            let maxValue = 0;

            for (let i = 0; i < octaves; i++) {
                value += amplitude * smoothNoise(x * frequency, y * frequency);
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }

            return value / maxValue;
        }

        // Eye shape functions
        function getEyeIntensity(x, y, centerX, centerY, time) {
            const dx = x - centerX;
            const dy = y - centerY;

            // Slight breathing animation
            const breathe = 1 + Math.sin(time * 0.5) * 0.03;

            // Almond/eye shape parameters
            const eyeWidth = Math.min(cols, rows) * 0.42 * breathe;
            const eyeHeight = eyeWidth * 0.38;

            // Iris and pupil
            const irisRadius = eyeWidth * 0.35;
            const pupilRadius = irisRadius * 0.4;

            // Distance calculations
            const dist = Math.sqrt(dx * dx + dy * dy);
            const eyeDist = Math.sqrt((dx / eyeWidth) ** 2 + (dy / eyeHeight) ** 2);

            // Almond shape - tapers at corners
            const almondFactor = Math.pow(Math.abs(dx / eyeWidth), 2.2);
            const adjustedEyeHeight = eyeHeight * (1 - almondFactor * 0.7);
            const almondDist = Math.sqrt((dx / eyeWidth) ** 2 + (dy / adjustedEyeHeight) ** 2);

            let intensity = 0;

            // Pupil - darkest center
            if (dist < pupilRadius) {
                const pupilFade = dist / pupilRadius;
                intensity = 0.03 + pupilFade * 0.08;
            }
            // Iris - bright ring with texture
            else if (dist < irisRadius) {
                const irisPos = (dist - pupilRadius) / (irisRadius - pupilRadius);

                // Radial striations
                const angle = Math.atan2(dy, dx);
                const striation = Math.sin(angle * 32 + time * 0.3) * 0.5 + 0.5;
                const striation2 = Math.sin(angle * 48 - time * 0.2) * 0.5 + 0.5;

                // Collarette ring
                const collarette = Math.abs(irisPos - 0.4) < 0.1 ? 0.15 : 0;

                // Limbal ring (dark edge)
                const limbalDark = irisPos > 0.85 ? (irisPos - 0.85) * 2 : 0;

                intensity = 0.2 + irisPos * 0.25 + striation * 0.08 + striation2 * 0.05 + collarette - limbalDark * 0.15;
            }
            // Sclera (white of eye) - inside almond shape
            else if (almondDist < 1) {
                const scleraFade = almondDist;
                intensity = 0.08 + (1 - scleraFade) * 0.06;

                // Slight redness/texture near edges
                if (almondDist > 0.7) {
                    intensity += (almondDist - 0.7) * 0.05;
                }
            }
            // Outside eye - ambient field
            else {
                const falloff = Math.max(0, 1 - (almondDist - 1) * 0.5);
                intensity = 0.02 * falloff;
            }

            return intensity;
        }

        // Ripple effect
        function getRippleEffect(x, y, time) {
            let effect = 0;

            for (let i = ripples.length - 1; i >= 0; i--) {
                const ripple = ripples[i];
                const age = time - ripple.startTime;

                if (age > 3) {
                    ripples.splice(i, 1);
                    continue;
                }

                const dx = x - ripple.x;
                const dy = y - ripple.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const speed = 80;
                const waveRadius = age * speed;
                const waveWidth = 25;

                const distFromWave = Math.abs(dist - waveRadius);

                if (distFromWave < waveWidth) {
                    const waveIntensity = (1 - distFromWave / waveWidth);
                    const decay = Math.exp(-age * 1.2);
                    effect += waveIntensity * decay * 0.4 * Math.sin(dist * 0.15 - age * 8);
                }
            }

            return effect;
        }

        function resize() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            width = rect.width;
            height = rect.height;

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.scale(dpr, dpr);

            cols = Math.ceil(width / CELL);
            rows = Math.ceil(height / CELL);
        }

        function draw() {
            ctx.fillStyle = '#030303';
            ctx.fillRect(0, 0, width, height);

            const centerX = cols / 2;
            const centerY = rows / 2;

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const x = i * CELL;
                    const y = j * CELL;

                    // Bayer dithering threshold
                    const bayerThreshold = BAYER_8x8[j % 8][i % 8];

                    // FBM noise for organic movement
                    const noiseVal = fbm(
                        i * 0.03 + time * 0.1,
                        j * 0.03 + time * 0.08,
                        4
                    );

                    // Secondary faster noise
                    const flickerNoise = fbm(
                        i * 0.1 + time * 0.5,
                        j * 0.1 - time * 0.3,
                        2
                    );

                    // Eye shape intensity
                    const eyeIntensity = getEyeIntensity(i, j, centerX, centerY, time);

                    // Ripple distortion
                    const rippleEffect = getRippleEffect(x, y, time);

                    // Combine all factors
                    let opacity = eyeIntensity;

                    // Add noise variation
                    opacity += (noiseVal - 0.5) * 0.08;

                    // Fast flicker for that CRT feel
                    opacity += (flickerNoise - 0.5) * 0.03;

                    // Ripple adds/subtracts brightness
                    opacity += rippleEffect;

                    // Dithering - sharp cutoff based on Bayer threshold
                    const ditheredOpacity = opacity > bayerThreshold * 0.5 ? opacity : opacity * 0.3;

                    // Clamp and apply
                    const finalOpacity = Math.max(0.01, Math.min(0.45, ditheredOpacity));

                    // Slight color variation - warmer in iris, cooler outside
                    const dist = Math.sqrt((i - centerX) ** 2 + (j - centerY) ** 2);
                    const irisRadius = Math.min(cols, rows) * 0.15;
                    const colorWarmth = dist < irisRadius ? 1 : 0.85 + Math.random() * 0.1;

                    ctx.fillStyle = `rgba(${ACCENT_R}, ${Math.floor(ACCENT_G * colorWarmth)}, ${ACCENT_B}, ${finalOpacity})`;
                    ctx.fillRect(x, y, PIXEL_SIZE, PIXEL_SIZE);
                }
            }

            time += 0.016;
            requestAnimationFrame(draw);
        }

        // Event listeners
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            ripples.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top,
                startTime: time
            });
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        window.addEventListener('resize', resize);

        // Initialize
        resize();
        draw();
    </script>
</body>
</html>
